--[[
	GhenTuong
	Discord: GhenTuong#1278
	Twitter: https://twitter.com/GhenTuong
--]]
local GT = game.translate_string

--[[----------------------------------------------------------------------------------------------------
	Utilities
------------------------------------------------------------------------------------------------------]]
function object_by_id(id)
	return id and (db.storage[id] and db.storage[id].object or level.object_by_id(id))
end

function cam_xform()
	local pos = device().cam_pos
	local dir = device().cam_dir
	return matrix():setHPB(dir:getH(),dir:getP(),0):translate_over(pos)
end

--[[----------------------------------------------------------------------------------------------------
	Manager
------------------------------------------------------------------------------------------------------]]
_G.MINE_MGR = nil

class "CMineManager"
function CMineManager:__init()
	self.MINE_ACT_OWN = {}
	
	self.cfg_item_to_mine = {}
	self.cfg_mine_to_item = {}
	
	local ini = ini_file([[items\settings\deploy.ltx]])
	if (ini:section_exist("mines")) then
		for idx,val in pairs(utils_data.collect_section(ini,"mines",true)) do
			if (ini_sys:section_exist(idx) and ini_sys:section_exist(val)) then
				self.cfg_item_to_mine[idx] = val
				self.cfg_mine_to_item[val] = idx
			else
				DEBUG("Section do not exist [%s] %s | [%s] %s",idx,ini_sys:section_exist(idx),val,ini_sys:section_exist(val))
			end
		end
	end
		
	RegisterScriptCallback("save_state",self)
	RegisterScriptCallback("load_state",self)
	RegisterScriptCallback("server_entity_on_unregister",self)
	RegisterScriptCallback("actor_on_first_update",self)
end

function CMineManager:save_state(m_data)
	m_data.GT_MINE_ACT_OWN = self.MINE_ACT_OWN
end

function CMineManager:load_state(m_data)
	self.MINE_ACT_OWN = m_data.GT_MINE_ACT_OWN or {}
end

function CMineManager:actor_on_first_update()
	for idx=#self.MINE_ACT_OWN,1,-1 do
		local id = self.MINE_ACT_OWN[idx]
		local se = id and alife_object(id)
		if (se) then
			if not (simulation_objects.is_on_the_actor_level(se)) then
				if (self:IsMine(se:section_name())) then
					DEBUG("Release mine for not in actor level [%s]",se:name())
					alife_release(se)
				else
					DEBUG("ERROR: object invalid [%s]",se:name())
					self:ActorOwnDel(se.id)
				end
			end
		else
			DEBUG("ERROR: object does not exist")
			self:ActorOwnDel(se.id)
		end
	end
end

function CMineManager:server_entity_on_unregister(se,flag)
	if (flag == "se_physic") and (self:IsMine(se:section_name())) then
		DEBUG("server_entity_on_unregister(%s)",se:name())
		self:ActorOwnDel(se.id)
	end
end

function CMineManager:IsMine(sec)
	return sec and (SYS_GetParam(0,sec,"kind") == "e_mine") and true or false
end

function CMineManager:ActorOwnAdd(id)
	for i,v in ipairs(self.MINE_ACT_OWN) do 
		if (v == id) then 
			return 
		end
	end
	self.MINE_ACT_OWN[#self.MINE_ACT_OWN+1] = id
end

function CMineManager:ActorOwnDel(id)
	for i,v in ipairs(self.MINE_ACT_OWN) do 
		if (v == id) then
			table.remove(self.MINE_ACT_OWN,i)
			break
		end
	end
end

function CMineManager:ItemToMine(sec)
	return sec and self.cfg_item_to_mine[sec]
end

function CMineManager:MinetoItem(sec)
	return sec and self.cfg_mine_to_item[sec]
end

function CMineManager:Create(prs,actor_own)
	local sec = prs and prs.sec
	local pos = prs and prs.pos
	local vid = prs and prs.vid
	local gid = prs and prs.gid
	local ang = prs and prs.ang
	if (sec and pos and vid and gid and ang and self:IsMine(sec)) then
		local se = alife_create(sec,pos,vid,gid)
		se.angle = vector():set(ang.y,ang.x,ang.z)
		if (actor_own) then
			self:ActorOwnAdd(se.id)
		end
		return true
	end
	DEBUG("Wrong parameters %s %s %s %s %s",sec,pos,vid,gid,ang)
	return false
end

--[[----------------------------------------------------------------------------------------------------
	Main
------------------------------------------------------------------------------------------------------]]
local CHECKOUT_SND = [[weapons\generic_checkout]]

db.mine_objects = {}

function add_binded_object(obj)
	db.mine_objects[obj:id()] = obj
end

function del_binded_object(obj)
	db.mine_objects[obj:id()] = nil
end

-- Mine is defused.
function TimeEvent_use_callback(oid)
	local obj = object_by_id(oid)
	local sec = obj and MINE_MGR:MinetoItem(obj:section())
	if (sec) then
		alife_create_item(sec,db.actor)
		alife_release(obj)
	end
	return true
end

-- Mine is triggered.
function on_physic_contact(obj,who)
	if (obj and who) then
		--DEBUG("%s %s",obj:name(),who:name())
		CreateTimeEvent(obj:id(),"TimeEvent_exp_callback",0,TimeEvent_exp_callback,obj:id())
	end
end

-- Mine spawns explosive.
function TimeEvent_exp_callback(oid)
	local obj = object_by_id(oid)
	local sec = obj and SYS_GetParam(0,obj:section(),"mine_attachment_section")
	if (sec and ini_sys:section_exist(sec)) then
		sound_object(CHECKOUT_SND):play_no_feedback(obj,sound_object.s3d,0,obj:position(),1,1)
		alife_create(sec,obj:position(),obj:level_vertex_id(),obj:game_vertex_id())
		alife_release(obj)
	end
	return true
end

function actor_on_item_use(obj)
	if (deploy_condition() and MINE_MGR:ItemToMine(obj:section())) then
		if (HUD) then
			HUD:Close()
		end
		hud_deploy_active(obj)
	end
end

function deploy_condition()
	if not (db.actor:alive()) then
		return false
	end
	if (db.actor:get_attached_vehicle()) then
		return false
	end
	if (db.actor:is_talking()) then
		return false
	end
	if (IsMoveState("mcClimb")) then
		return false
	end
	return true
end

--[[----------------------------------------------------------------------------------------------------
	UIDeploy
------------------------------------------------------------------------------------------------------]]
HUD = nil

function hud_deploy_active(obj)
	if (HUD == nil) then
		HUD = UIDeploy(obj)
		get_hud():AddDialogToRender(HUD)
		RegisterScriptCallback("on_key_press",on_key_press)
	end
end

function hud_deploy_remove()
	if (HUD) then
		get_hud():RemoveDialogToRender(HUD)
		HUD = nil
		UnregisterScriptCallback("on_key_press",on_key_press)
	end
end

function hud_deploy_update()
	if (HUD) then
		HUD:Update(true)
	end
end

function on_key_press(dik)
	if (HUD) then
		HUD:OnKeyPress(dik)
	end
end

class "UIDeploy" (CUIScriptWnd)
function UIDeploy:__init(obj) super(obj)
	self:SetWndRect(Frect():set(0,0,1280,768))
	self:SetAutoDelete(true)
	
	self.oid = obj:id()
	self.sec = obj:section()
	self.vis = self:GetAttachmentVisual(obj)
	self.atm_name = "deploy_mine"
	self.dist_def = 1
	self.dist_max = 3
	self.horz_min = 1
	self.horz_max = 2
	
	self.exclusive_radius = 0.4
	self.exclusive_height = 0.05
	self.vec_up = vector():set(VEC_Y)
	self.vec_dw = vector():set(self.vec_up):invert()
	
	self.rotation = 0
	
	self.active = db.actor:active_slot()
	self.hiding = (self.active ~= 0) and true or false
	db.actor:activate_slot(0)
	hide_hud_inventory()
end

function UIDeploy:__finalize()
end

function UIDeploy:Update()
	CUIScriptWnd.Update(self)
	
	if not (main_hud_shown()) then
		return self:Close()
	end
	
	if not (deploy_condition()) then
		return self:Close()
	end
	
	if not (object_by_id(self.oid)) then
		return self:Close()
	end
	
	if not (self.vis) then
		return self:Close()
	end
	
	if (self.hiding) then
		if (db.actor:active_slot() == 0) then
			self.hiding = false
		elseif (db.actor:active_slot() ~= self.active) then
			return self:Close()
		end
	else
		if (db.actor:active_slot() ~= 0) then
			return self:Close()
		end
	end
	
	self.pos = self:GetAttachmentPosition()
	self.dir = self:GetAttachmentRotation(self.pos)
	
	if (self.pos and self.dir) then
		if (db.actor:get_attachment(self.atm_name) == nil) then
			db.actor:add_attachment(self.atm_name,self.vis):set_type(script_attachment_type.CamAttached)
		end
		local atm = db.actor:get_attachment(self.atm_name)
		if (atm) then
			atm:set_position(self.pos)
			local h = 180
			local p = math.deg(device().cam_dir:getP()) - math.deg(self.dir:getP())
			local b = self.rotation
			atm:set_rotation(h,p,b)
		end
	else
		if (db.actor:get_attachment(self.atm_name)) then
			db.actor:remove_attachment(self.atm_name)
		end
	end
end

function UIDeploy:Deploy()
	if (self.hiding) then
		return
	end
	if (self:CheckDeployPosition() == false) then
		return
	end
	local atm = db.actor:get_attachment(self.atm_name)
	local xfm = atm and atm:get_transform()
	if not (xfm) then
		return
	end
	local obj = object_by_id(self.oid)
	local k = {}
	k.sec = MINE_MGR:ItemToMine(obj:section())
	k.pos = vector():set(xfm.c)
	k.vid = db.actor:level_vertex_id()
	k.gid = db.actor:game_vertex_id()
	k.ang = xfm:getHPB()
	if (MINE_MGR:Create(k,true)) then
		itms_manager.play_item_sound(obj,0.75)
		news_manager.relocate_item(db.actor,"out",obj:section())
		alife_release(obj)
	end
	self:ResumeActive()
	return self:Close()
end

function UIDeploy:Rotate(klockwise)
	local num = klockwise and -10 or 10
	self.rotation = clamp(self.rotation + num,-90,90)
end

function UIDeploy:GetAttachmentVisual(obj)
	local sec = obj and MINE_MGR:ItemToMine(obj:section())
	return sec and SYS_GetParam(0,sec,"visual")
end

function UIDeploy:GetAttachmentPosition()
	local pos = device().cam_pos
	local dir = device().cam_dir
	if (dir:getP() > 0) then
		return
	end
	local ray = ray_pick(pos,dir,self.dist_max,2,db.actor)
	local vec = ray:query() and vector():set(0,0,ray:get_distance())
	if (vec) then
		local tmp = vector():set(vec)
		cam_xform():transform_tiny(tmp)
		local dis = db.actor:position():distance_to_xz_sqr(tmp)
		if (dis > math.pow(self.horz_min,2)) and (dis < math.pow(self.horz_max,2)) then
			return vec
		end
	end
end

function UIDeploy:GetAttachmentRotation(pos)
	if not (pos) then
		return
	end
	local src = vector():set(pos)
	cam_xform():transform_tiny(src)
	local tmp = vector():set(src):add(vector():set(0,0.5,0))
	local dir = vector():setHP(device().cam_dir:getH() + math.rad(self.rotation),0):normalize()
	local ray = ray_pick(tmp,dir,2,3,db.actor)
	if (ray:query()) then
		return
	end
	local vec = vector():mad(tmp,dir,2)
	local ray = ray_pick(vec,self.vec_dw,1,2,db.actor)
	if not (ray:query()) then
		return
	end
	local dst = vector():mad(vec,self.vec_dw,ray:get_distance())
	return vector():sub(dst,src):normalize()
end

function UIDeploy:CheckDeployPosition()
	return true
end

function UIDeploy:ResumeActive()
	if (self.active ~= 0) then
		db.actor:activate_slot(self.active)
	end
end

function UIDeploy:Cancel()
	self:ResumeActive()
	return self:Close()
end

function UIDeploy:Close()
	if (db.actor:get_attachment(self.atm_name)) then
		db.actor:remove_attachment(self.atm_name)
	end
	hud_deploy_remove()
end

function UIDeploy:OnKeyPress(dik)
	if (dik == DIK_keys.MOUSE_1) then
		return self:Deploy()
	end
	if (dik == DIK_keys.MOUSE_2) then
		return self:Cancel()
	end
	if (dik == DIK_keys.DIK_R) then
		return self:Rotate(false)
	end
	if (dik == DIK_keys.DIK_T) then
		return self:Rotate(true)
	end
end

--[[----------------------------------------------------------------------------------------------------
	Mine
------------------------------------------------------------------------------------------------------]]
function init(obj)
	obj:bind_object(CMineBinder(obj))
end

class "CMineBinder" (object_binder)
function CMineBinder:__init(obj) super(obj)
	db.storage[self.object:id()] = {}
	self.oid = self.object:id()
	local section = self.object:section()
	
	-- Physic object.
	self.defuse		= false
	self.defuse_use = SYS_GetParam(0,section,"mine_defuse_use","false") == "true" and true or false
	self.defuse_tip = SYS_GetParam(0,section,"mine_defuse_tip","st_defuse")
	
	self.fc_timer = nil
	self.fc_delay = 100
	self.object:set_fastcall(self.update,self)
end

function CMineBinder:reload(section)
	object_binder.reload(self,section)
end

function CMineBinder:reinit()
	object_binder.reinit(self)
	db.storage[self.object:id()] = db.storage[self.object:id()] or {}
	self.st = db.storage[self.object:id()]
end

--[[----------------------------------------------------------------------------------------------------
	Update
------------------------------------------------------------------------------------------------------]]
function CMineBinder:update(delta)
	object_binder.update(self,delta)
	local t = time_global()
	if (self.fc_timer and (self.fc_timer > t)) then
		return
	end
	self.fc_timer = t + self.fc_delay
	
	if (self.defuse ~= true) then
		self.defuse = true
		--DEBUG("[%s] %s %s",self.object:name(),self.defuse_use,self.defuse_tip)
		self.object:set_nonscript_usable(self.defuse_use)
		self.object:set_tip_text(self.defuse_tip)
	end
end

function CMineBinder:use_callback(obj,who)
	if (obj:position():distance_to_sqr(who:position()) > math.pow(2,2)) then
		return
	end
	CreateTimeEvent(obj:id(),"TimeEvent_use_callback",0,TimeEvent_use_callback,obj:id())
end

function CMineBinder:hit_callback(obj,power,dir,who,bone_id)
	CreateTimeEvent(obj:id(),"TimeEvent_exp_callback",0,TimeEvent_exp_callback,obj:id())
end

--[[----------------------------------------------------------------------------------------------------
	Schemes
------------------------------------------------------------------------------------------------------]]
function CMineBinder:net_spawn(se_abstract)
	if not (object_binder.net_spawn(self,se_abstract)) then
		return false
	end
	db.add_obj(self.object)
	add_binded_object(self.object)
	self.object:set_callback(callback.hit,self.hit_callback,self)
	self.object:set_callback(callback.use_object,self.use_callback,self)
	return true
end

function CMineBinder:net_destroy()
	self.object:set_callback(callback.hit,nil)
	self.object:set_callback(callback.use_object,nil)
	db.del_obj(self.object)
	del_binded_object(self.object)
	object_binder.net_destroy(self)
end

function CMineBinder:net_save_relevant()
	return true
end

function CMineBinder:save(packet)
	object_binder.save(self,packet)
	set_save_marker(packet,"save",false,"physics_binder")
	set_save_marker(packet,"save",true,"physics_binder")
end

function CMineBinder:load(packet)
	object_binder.load(self,packet)
	set_save_marker(packet,"load",false,"physics_binder")
	set_save_marker(packet,"load",true,"physics_binder")
end

--[[----------------------------------------------------------------------------------------------------
	Explosive
------------------------------------------------------------------------------------------------------]]
function init_explosive(obj)
	obj:bind_object(CExplosiveBinder(obj))
end

class "CExplosiveBinder" (object_binder)
function CExplosiveBinder:__init(obj) super(obj)
	db.storage[self.object:id()] = {}
	self.oid = self.object:id()
	
	self.fc_timer = nil
	self.fc_delay = 100
	self.object:set_fastcall(self.update,self)
end

function CExplosiveBinder:reload(section)
	object_binder.reload(self,section)
end

function CExplosiveBinder:reinit()
	object_binder.reinit(self)
	db.storage[self.object:id()] = db.storage[self.object:id()] or {}
	self.st = db.storage[self.object:id()]
end

function CExplosiveBinder:update(delta)
	object_binder.update(self,delta)
	local t = time_global()
	if (self.fc_timer and (self.fc_timer > t)) then
		return
	end
	self.fc_timer = t + self.fc_delay
	
	self:Explode()
end

function CExplosiveBinder:Explode()
	local h = hit()
	h.type		= hit.fire_wound
	h.power		= 100
	h.impulse	= 0
	h.direction	= VEC_Y
	if (SYS_GetParam(0,self.object:section(),"mine_owner_actor","false") == "true") then
		h.draftsman	= db.actor
	else
		h.draftsman	= self.object
	end
	self.object:hit(h)
end

function CExplosiveBinder:net_spawn(se_abstract)
	if not (object_binder.net_spawn(self,se_abstract)) then
		return false
	end
	db.add_obj(self.object)
	return true
end

function CExplosiveBinder:net_destroy()
	db.del_obj(self.object)
	object_binder.net_destroy(self)
end

function CExplosiveBinder:net_save_relevant()
	return true
end

function CExplosiveBinder:save(packet)
	object_binder.save(self,packet)
	set_save_marker(packet,"save",false,"physics_binder")
	set_save_marker(packet,"save",true,"physics_binder")
end

function CExplosiveBinder:load(packet)
	object_binder.load(self,packet)
	set_save_marker(packet,"load",false,"physics_binder")
	set_save_marker(packet,"load",true,"physics_binder")
end

--[[----------------------------------------------------------------------------------------------------
	Callbacks
------------------------------------------------------------------------------------------------------]]
function on_show_hide()
	hud_deploy_update()
end

function actor_on_net_destroy()
	hud_deploy_remove()
end

--[[----------------------------------------------------------------------------------------------------
	Registers
------------------------------------------------------------------------------------------------------]]
function on_game_start()
	_G.MINE_MGR = CMineManager()
	RegisterScriptCallback("GUI_on_show",on_show_hide)
	RegisterScriptCallback("GUI_on_hide",on_show_hide)
	RegisterScriptCallback("actor_on_net_destroy",actor_on_net_destroy)
	RegisterScriptCallback("actor_on_item_use",actor_on_item_use)
end

function DEBUG(str,...)
	local func = debug.getinfo(2,"S").source
	local line = debug.getinfo(2,"l").currentline
	func = string.sub(func,#func - string.find(string.reverse(func),"\\") + 2,#func)
	local p = {...}
	if (p and (#p ~= 0)) then
		printf(string.format("[GhenTuong] %s:%s | %s",tostring(func),tostring(line),str),...)
	else
		printf(string.format("[GhenTuong] %s:%s | ",tostring(func),tostring(line)) .. "%s",str)
	end
end